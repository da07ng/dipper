// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See http://js.arcgis.com/4.0beta2/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/RibbonLineMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonLine"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n\tuniform mat4 model;\r\n\r\n\tuniform float extLineWidth;\r\n\tuniform float nearPlane;\r\n\r\n\tattribute vec3 $position;\t\r\n\tattribute vec2 $uv0;\r\n\tvarying vec2 vtc;\r\n\r\n\tattribute vec4 $color;\r\n\tvarying vec4 vColor;\r\n\r\n\tattribute float size;\r\n\r\n#ifndef WALL\r\n\tuniform float miterLimit;\r\n\tattribute vec3 $auxpos1;\r\n\tattribute vec3 $auxpos2;\r\n#endif\r\n\r\n#ifdef SCREENSCALE\r\n\tuniform vec2 screenSize;\r\n\t$toScreenCoords\r\n#define VECTYPE vec2\r\n#define ZEROVEC vec2(0.0, 0.0)\r\n#define PERPENDICULAR(v) vec2(v.y, -v.x);\r\n#define ISOUTSIDE (left.x * right.y - left.y * right.x)*$uv0.y \x3e 0.0\r\n\r\n#else //ifdef SCREENSCALE\r\n\r\n#define VECTYPE vec3\r\n#define ZEROVEC vec3(0.0, 0.0, 0.0)\r\n// these macros are only valid for "strip" type lines:\r\n#define PERPENDICULAR(v) cross(up/*vec3(0.0, 1.0, 0.0)*/, v)\r\n#define ISOUTSIDE dot(cross(left, right), up/*vec3(0.0, 1.0, 0.0)*/)*$uv0.y \x3c 0.0\r\n\r\n#endif //ifdef SCREENSCALE\r\n\r\n\tfloat interp(float ncp, vec4 a, vec4 b) {\r\n\t\treturn (-ncp - a.z) / (b.z - a.z);\r\n\t}\r\n\r\n#ifdef SCREENSCALE\r\n\r\n  void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next) {\r\n\t\tfloat vnp \x3d nearPlane*0.99;\r\n\r\n\t\t//We have four vertices per point on the line. Start and end vertices \r\n\t\t//are treated differently --\x3e d \x3e 0, d \x3c 0\r\n\t\tfloat d \x3d abs($uv0.y) - 1.1;\r\n\r\n\t\t//current pos behind ncp --\x3e we need to clip\r\n\t\tif(pos.z \x3e -nearPlane) {\t\t\t\r\n\t\t\tif (d \x3c 0.0) {\r\n\t\t\t\t//previous in front of ncp\r\n\t\t\t\tif(prev.z \x3c -nearPlane) {\r\n\t\t\t\t\tpos \x3d mix(prev, pos, interp(vnp, prev, pos));\r\n\t\t\t\t\tnext \x3d pos;\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t  pos \x3d vec4(0, 0, 0, 1);\r\n\t\t\t  }\r\n\t\t\t}\r\n\t\t\t//next in front of ncp\r\n\t\t\tif(d \x3e 0.0) {\r\n\t\t\t\tif(next.z \x3c -nearPlane) {\r\n\t\t\t\t\tpos \x3d mix(pos, next, interp(vnp, pos, next));\r\n\t\t\t\t\tprev \x3d pos;\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpos \x3d vec4(0, 0, 0, 1);\r\n\t\t\t\t}\r\n\t\t\t}\t\t\t\r\n\t\t}\telse { \r\n\t\t\t//current position visible \r\n\t\t\t//previous behind ncp\r\n\t\t\tif (prev.z \x3e -nearPlane) {\t\t\t\t\r\n\t\t\t\tprev \x3d mix(pos, prev, interp(vnp, pos, prev));\t\t\t\t\r\n\t\t\t}\t\t\t\t\t\r\n\t\t\t//next behind ncp\r\n\t\t\tif (next.z \x3e -nearPlane) {\r\n\t\t\t\tnext \x3d mix(next, pos, interp(vnp, next, pos));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpos\x3d proj * pos;\r\n\t\tpos.xy *\x3d screenSize;\r\n\t\tpos /\x3d pos.w;\r\n\r\n\t\tnext \x3d proj * next;\r\n\t\tnext.xy *\x3d screenSize;\r\n\t\tnext /\x3d next.w;\r\n\r\n\t\tprev \x3d proj * prev;\r\n\t\tprev.xy *\x3d screenSize;\r\n\t\tprev /\x3d prev.w;\t\t\r\n  }\r\n\r\n#endif // SCREENSCALE\r\n\r\n\tvoid main(void) {\r\n\r\n\tfloat lineWidth \x3d extLineWidth + $size; \r\n\r\n#ifdef SCREENSCALE\r\n\r\n#if 0\r\n\t\tvec4 pos \x3d toScreenCoords($position.xyz);\r\n\t\tvec2 left \x3d (pos - toScreenCoords($auxpos1)).xy;\r\n\t\tvec2 right \x3d (toScreenCoords($auxpos2) - pos).xy;\r\n#else\r\n\t\tvec4 pos  \x3d view * vec4((model * vec4($position.xyz, 1.0)).xyz, 1.0); \r\n\t\tvec4 prev \x3d view * vec4((model * vec4($auxpos1.xyz, 1.0)).xyz, 1.0); \r\n\t\tvec4 next \x3d view * vec4((model * vec4($auxpos2.xyz, 1.0)).xyz, 1.0); \r\n\r\n\t\tclipAndTransform(pos, prev, next);\r\n\r\n\t\tvec2 left \x3d (pos - prev).xy;\r\n\t\tvec2 right \x3d (next - pos).xy;\r\n#endif\r\n\r\n#else // ifdef SCREENSCALE\r\n\t\tvec4 pos \x3d vec4($position, 1.0);\r\n#ifndef WALL\r\n\t\tvec3 left \x3d $position.xyz - $auxpos1;\r\n\t\tvec3 right \x3d $auxpos2 - $position.xyz;\r\n\t\tvec3 up \x3d normalize($position.xyz);\r\n#endif // ifndef WALL\r\n#endif // ifdef SCREENSCALE\r\n\r\n#ifdef WALL\r\n\t\tfloat displacementLen \x3d lineWidth;\r\n\t\tvec3 displacementDir \x3d normalize($position.xyz);//vec3(0.0, 1.0, 0.0);\r\n#else // ifdef WALL\r\n\r\n\t\tfloat leftLen \x3d length(left);\r\n\t\tleft \x3d (leftLen \x3e 0.001) ? left/leftLen : ZEROVEC;\r\n\r\n\t\tfloat rightLen \x3d length(right);\r\n\t\tright \x3d (rightLen \x3e 0.001) ? right/rightLen : ZEROVEC;\r\n\r\n\t\t// determine if vertex is on the "outside or "inside" of the join\r\n\t\tbool isOutside \x3d ISOUTSIDE;\r\n\r\n\t\t// compute miter join position first\r\n\t\tfloat displacementLen \x3d lineWidth;\r\n\t\tVECTYPE displacementDir \x3d normalize(left + right);\r\n\t\tdisplacementDir \x3d PERPENDICULAR(displacementDir);\r\n\t\tif (leftLen \x3e 0.001 \x26\x26 rightLen \x3e 0.001) {\r\n\t\t\tfloat nDotSeg \x3d dot(displacementDir, left);\r\n\t\t\tdisplacementLen /\x3d length(nDotSeg*left - displacementDir);\r\n\r\n\t\t\t// limit displacement of inner vertices\r\n\t\t\tif (!isOutside)\r\n\t\t\t\tdisplacementLen \x3d min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\r\n\t\t}\r\n\r\n\t\tif (isOutside \x26\x26 (displacementLen \x3e miterLimit*lineWidth)) {\r\n\t\t\t// convert to bevel join if miterLimit is exceeded\r\n\t\t\tif (leftLen \x3c 0.001)\r\n\t\t\t    displacementDir \x3d right;\r\n\t\t\telse if (rightLen \x3c 0.001)\r\n\t\t\t\tdisplacementDir \x3d left;\r\n\t\t\telse\r\n\t\t\t\tdisplacementDir \x3d (abs($uv0.y) - 1.1 \x3c 0.0) ? left : right;\r\n\t\t\tdisplacementDir \x3d normalize(displacementDir);\r\n\t\t\tdisplacementDir \x3d PERPENDICULAR(displacementDir);\r\n\t\t\tdisplacementLen \x3d lineWidth;\r\n\t\t}\r\n\r\n#endif // ifdef WALL\r\n\r\n#ifdef SCREENSCALE\r\n\t\tpos.xy +\x3d displacementDir * floor($uv0.y + 0.5) * displacementLen;\r\n\t\tpos.xy /\x3d screenSize;\r\n#else\r\n\t\tpos.xyz +\x3d displacementDir * floor($uv0.y + 0.5) * displacementLen;\r\n\t\tpos \x3d proj * view * model * pos;\r\n#endif\r\n\r\n\t\tvtc \x3d $uv0;\r\n\t\tvColor \x3d $color * 0.003921568627451; // \x3d 1/255\r\n\t\tgl_Position \x3d pos;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonLine"\x3e\x3c![CDATA[\r\n\tprecision mediump float;\r\n\r\n\tuniform vec4 eColor;\r\n\tvarying vec4 vColor;\r\n\tvarying vec2 vtc;\r\n\r\n\tvoid main() {\r\n\t\tgl_FragColor \x3d eColor * vColor;\r\n\t\t//gl_FragColor.a \x3d 1;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e'}});
define("dojo/_base/lang dojo/text!./RibbonLineMaterial.xml ./internal/MaterialUtil ../lib/VertexBufferLayout ../lib/GLSLProgram ../lib/GLSLShader ../lib/Util ../lib/gl-matrix ../lib/webglConstants".split(" "),function(L,M,D,G,E,B,C,u,y){var N=[255,255,255,255],O=[0,0,0,0],g=u.vec3d,H=u.vec2d,I=u.mat4d,p=g.create(),q=g.create(),r=g.create(),F=g.create(),z=H.create(),A=H.create(),J=g.create(),K=g.create();u=function(e,u){D.basicMaterialConstructor(this,u);var h=C.VertexAttrConstants;e=e||{};e.color=
e.color||[1,1,1,1];e.width=e.width||0;e.type=e.type||"screen";e.join=e.join||"miter";e.miterLimit="miter"===e.join?e.miterLimit||5:e.miterLimit;var f="wall"===e.type?2:4,c="wall"===e.type?new G([h.POSITION,h.UV0],[3,2]):new G([h.POSITION,h.UV0,h.AUXPOS1,h.AUXPOS2,h.COLOR,h.SIZE],[3,2,3,3,4,1],[y.FLOAT,y.FLOAT,y.FLOAT,y.FLOAT,y.FLOAT,y.FLOAT]);this.canBeMerged=!1;this.getParams=function(){return e};this.getParameterValues=function(){var s={color:e.color,width:e.width,type:e.type,join:e.join,polygonOffset:e.polygonOffset};
"miter"===e.join&&(s.miterLimit=e.miterLimit);return s};this.setParameterValues=function(s){for(var d in s)s.hasOwnProperty(d)&&(C.assert("type"!==d,"RibbonLineMaterial: type cannot be changed after creation"),e[d]=s[d]);this.notifyDirty("matChanged")};this.dispose=function(){};this.getOutputAmount=function(e){return((e/2+1-2)*f+4)*c.getStride()};this.getVertexBufferLayout=function(){return c};this.fillInterleaved=function(s,d,c,l,a,b){c=s.vertexAttr[h.POSITION].data;l=s.vertexAttr[h.COLOR]?s.vertexAttr[h.COLOR].data:
N;s=s.vertexAttr[h.SIZE]?s.vertexAttr[h.SIZE].data:O;if("wall"===e.type){l=b;s=c.length/3;b=0;for(var f=c[0],k=c[1],n=c[2],m,g,t,p=0;p<s;p++){var q=3*p;m=f;g=k;t=n;f=c[q];k=c[q+1];n=c[q+2];d&&(f=d[0]*f+d[4]*k+d[8]*n+d[12],k=d[1]*f+d[5]*k+d[9]*n+d[13],n=d[2]*f+d[6]*k+d[10]*n+d[14]);b+=Math.sqrt((f-m)*(f-m)+(k-g)*(k-g)+(n-t)*(n-t));a[l++]=f;a[l++]=k;a[l++]=n;a[l++]=b;a[l++]=-1;a[l++]=f;a[l++]=k;a[l++]=n;a[l++]=b;a[l++]=1}}else{f=c.length/3;k=c[0];n=c[1];m=c[2];g=0;d&&(k=d[0]*k+d[4]*n+d[8]*m+d[12],n=
d[1]*k+d[5]*n+d[9]*m+d[13],m=d[2]*k+d[6]*n+d[10]*m+d[14]);t=k;var p=n,q=m,v=c[3],w=c[4],x=c[5];d&&(v=d[0]*v+d[4]*w+d[8]*x+d[12],w=d[1]*v+d[5]*w+d[9]*x+d[13],x=d[2]*v+d[6]*w+d[10]*x+d[14]);for(var r=0;r<f;r++){var u=3*r;r<f-1&&(v=c[u+3],w=c[u+4],x=c[u+5],d&&(v=d[0]*v+d[4]*w+d[8]*x+d[12],w=d[1]*v+d[5]*w+d[9]*x+d[13],x=d[2]*v+d[6]*w+d[10]*x+d[14]));g+=Math.sqrt((t-k)*(t-k)+(p-n)*(p-n)+(q-m)*(q-m));a[b++]=t;a[b++]=p;a[b++]=q;a[b++]=g;a[b++]=0===r?-1.2:-1;a[b++]=k;a[b++]=n;a[b++]=m;a[b++]=v;a[b++]=w;a[b++]=
x;a[b++]=l[0];a[b++]=l[1];a[b++]=l[2];a[b++]=l[3];a[b++]=s[0];a[b++]=t;a[b++]=p;a[b++]=q;a[b++]=g;a[b++]=0===r?1.2:1;a[b++]=k;a[b++]=n;a[b++]=m;a[b++]=v;a[b++]=w;a[b++]=x;a[b++]=l[0];a[b++]=l[1];a[b++]=l[2];a[b++]=l[3];a[b++]=s[0];0<r&&r<f-1&&(a[b++]=t,a[b++]=p,a[b++]=q,a[b++]=g,a[b++]=-1.2,a[b++]=k,a[b++]=n,a[b++]=m,a[b++]=v,a[b++]=w,a[b++]=x,a[b++]=l[0],a[b++]=l[1],a[b++]=l[2],a[b++]=l[3],a[b++]=s[0],a[b++]=t,a[b++]=p,a[b++]=q,a[b++]=g,a[b++]=1.2,a[b++]=k,a[b++]=n,a[b++]=m,a[b++]=v,a[b++]=w,a[b++]=
x,a[b++]=l[0],a[b++]=l[1],a[b++]=l[2],a[b++]=l[3],a[b++]=s[0]);k=t;n=p;m=q;t=v;p=w;q=x}}};this.intersect=function(c,d,f,l,a,b,u,k,n,m,y,t){if(t){d=c.getData().getVertexAttr(h.position).position.data;c=c.getData().getVertexAttr(h.SIZE).size;c=(c&&c.data[0])+e.width;u=Number.MAX_VALUE;for(k=0;k<d.length-5;k+=3){p[0]=d[k];p[1]=d[k+1];p[2]=d[k+2];I.multiplyVec3(f,p);q[0]=d[k+3];q[1]=d[k+4];q[2]=d[k+5];I.multiplyVec3(f,q);n.projectPoint(p,z);n.projectPoint(q,A);if(0>z[2]&&0<A[2])g.subtract(p,q,r),m=n.frustumPlanes,
t=-(g.dot(m[4],p)+m[4][3]),m=t/g.dot(r,m[4]),g.scale(r,m,r),g.add(p,r,p),n.projectPoint(p,z);else if(0<z[2]&&0>A[2])g.subtract(q,p,r),m=n.frustumPlanes,t=-(g.dot(m[4],q)+m[4][3]),m=t/g.dot(r,m[4]),g.scale(r,m,r),g.add(q,r,q),n.projectPoint(q,A);else if(0>z[2]&&0>A[2])continue;m=C.projectVectorVector2D(z,A,l);m<u&&(u=m,g.set(p,J),g.set(q,K))}u<c/2+4&&(f=C.linelineDistance3D(J,K,a,b),l=Number.MAX_VALUE,f[0]&&(g.subtract(f[2],a,F),l=0.98*g.length(F)/g.dist(a,b)),y(l,F))}};this.getGLMaterials=function(){return[P,
void 0,void 0]};this.getAllTextureIds=function(){return[]}};var P=function(e,g){D.basicGLMaterialConstructor(this,e);var h=L.clone(e.getParams());h.miterLimit="miter"===h.join?h.miterLimit:0;delete h.join;var f=g.get("ribbonLine_"+h.type);this.updateParameters=function(){var c=e.getParams();h.polygonOffset=c.polygonOffset;h.color=c.color;h.width=c.width;h.miterLimit="miter"===c.join?c.miterLimit:0};this.beginSlot=function(c){return 2===c};this.getProgram=function(){return f};this.bind=function(c,
g){f.use();f.uniform4fv("eColor",h.color);f.uniform1f("miterLimit",h.miterLimit);f.uniform1f("nearPlane",g.nearFar[0]);"screen"===h.type?(f.uniform2fv("screenSize",[g.viewport[2],g.viewport[3]]),f.uniform1f("extLineWidth",h.width*g.pixelRatio)):f.uniform1f("extLineWidth",h.width);e.getVertexBufferLayout().enableVertexAttribArrays(c,f);h.polygonOffset&&(c.enable(c.POLYGON_OFFSET_FILL),c.polygonOffset(0,-4));c.enable(c.BLEND);c.web3DDefaultState.cullEnabled&&c.disable(c.CULL_FACE);1>h.color[3]&&c.depthMask(!1)};
this.release=function(c){e.getVertexBufferLayout().disableVertexAttribArrays(c,f);h.polygonOffset&&c.disable(c.POLYGON_OFFSET_FILL);c.disable(c.BLEND);c.web3DDefaultState.cullEnabled&&c.enable(c.CULL_FACE);c.depthMask(!0)};this.bindView=function(c,e){D.bindView(e.origin,e.view,f)};this.bindInstance=function(c,e){f.uniformMatrix4fv("model",e.transformation)};this.getDrawMode=function(c){return c.TRIANGLE_STRIP}};u.loadShaders=function(e,g,h,f){e._parse(M);var c=new B(f.VERTEX_SHADER,e.vsRibbonLine,
f,["SCREENSCALE"]),p=new B(f.VERTEX_SHADER,e.vsRibbonLine,f);g=new B(f.VERTEX_SHADER,e.vsRibbonLine,f,["WALL"]);e=new B(f.FRAGMENT_SHADER,e.fsRibbonLine,f);c=new E([c,e],f);p=new E([p,e],f);f=new E([g,e],f);h.add("ribbonLine_screen",c);h.add("ribbonLine_strip",p);h.add("ribbonLine_wall",f)};return u});