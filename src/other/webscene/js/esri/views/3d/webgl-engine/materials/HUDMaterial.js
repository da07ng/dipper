// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See http://js.arcgis.com/4.0beta2/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/HUDMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"HUDMaterialCommonVariables"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n\tuniform vec4 viewport;\r\n\tuniform vec3 camPos;\r\n\tuniform float pixelRatio;\r\n\tuniform vec2 screenOffset;\r\n\tuniform vec2 anchorPos;\r\n\tuniform float polygonOffset;\r\n\r\n\tattribute vec3 $position;\r\n\tattribute vec3 $normal;\r\n\tattribute vec2 $uv0;\r\n\tattribute vec4 $color;\r\n  attribute vec2 $size;\r\n  attribute vec4 $auxpos1;\r\n\r\n\tvarying vec4 vcolor;\r\n\t\r\n#ifdef OCCL_PIXELSHADER\r\n \tvarying vec4 vtc;\r\n#else\r\n\tvarying vec2 vtc;\r\n\tvarying vec2 vsize;\r\n\tuniform sampler2D framebufferTex;\r\n\tuniform vec3 markerColor;\r\n#endif\t\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"matchPixelOrigin"\x3e\x3c![CDATA[\r\n\tvec4 matchPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\r\n\t\tvec2 xy \x3d vec2(.5) + .5 * clipCoord.xy / clipCoord.w;\r\n\t\tvec2 pixelSz \x3d vec2(1.0) / widthHeight;\r\n\t\tvec2 ij \x3d floor((xy + .5 * pixelSz) * widthHeight);\r\n\t\tvec2 result \x3d ((ij * pixelSz) * 2.0 - vec2(1.0)) * clipCoord.w;\r\n\t\treturn vec4(result.x, result.y, clipCoord.z, clipCoord.w);\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"calcPosMatchPixelCenter"\x3e\x3c![CDATA[\r\n\r\n\t\tvec3 posModel \x3d (model * vec4($position, 1.0)).xyz;\r\n\t\tvec3 posView \x3d (view * vec4(posModel, 1.0)).xyz;\r\n\r\n\t\tvec3 vnormal \x3d (modelNormal * vec4($normal, 1.0)).xyz;\r\n\r\n\t\t// view angle dependent part of polygon offset emulation\r\n\t\tfloat cosAlpha \x3d dot(vnormal, normalize(camPos - posModel));\r\n\t\tif (cosAlpha \x3e .01) {\r\n\t\t\tfloat tanAlpha \x3d sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\r\n\t\t\tposView *\x3d 1.0 - tanAlpha / viewport[2];\r\n\t\t}\r\n\r\n\t    if (centerOffset.w\x3c0.0)\r\n            posView+\x3dcenterOffset.xyz;\r\n\r\n\t\tvec4 posProj \x3d proj * vec4(posView, 1.0);\r\n\r\n\t\t// constant part of polygon offset emulation\r\n\t\tif (cosAlpha \x3e .01)\r\n\t\t\tposProj.z -\x3d polygonOffset * posProj.w;\r\n\r\n\t\tposProjCenter \x3d matchPixelCenter(posProj, viewport.zw);\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUD"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\t$matchPixelCenter\r\n\t$matchPixelOrigin\r\n\r\n\tvoid main(void) {\r\n\r\n\t    vec4 centerOffset \x3d $auxpos1;\r\n\r\n\t\tvec2 combinedSize \x3d $size * pixelRatio;\r\n\r\n        vec4 posProjCenter;\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\t\t\tvec2 uv01 \x3d floor($uv0);\r\n\t\t\tvec2 uv \x3d $uv0 - uv01;\r\n\t\t\tfloat dist \x3d distance(camPos, posModel);\r\n\t\t\tposProj.xy +\x3d ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffset)/ viewport.zw * posProj.w;\r\n\t\t\tvtc.xy \x3d uv;\r\n\t\t\tvsize \x3d $size;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tgl_Position \x3d matchPixelOrigin(posProj, viewport.zw);\r\n\t\tvcolor \x3d $color / 255.0;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDWorldScale"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\tuniform vec2 minMaxWorldSizeFactor;\r\n\r\n\t$matchPixelCenter\r\n\t$matchPixelOrigin\r\n\r\n\tvoid main(void) {\r\n\t    vec4 centerOffset \x3d $auxpos1;\r\n\t    vec2 combinedSize \x3d $size * pixelRatio;\r\n\t    \r\n\t    vec4 posProjCenter;\r\n\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\t\t\tfloat scale \x3d 1.0;\r\n\t\t\tvec2 minMaxWorldSize \x3d distance(camPos, position)*minMaxWorldSizeFactor;\r\n\t\t\tif (minMaxWorldSize.x \x3e combinedSize.y)\r\n\t\t\t\tscale \x3d minMaxWorldSize.x / combinedSize.y;\r\n\t\t\telse if (minMaxWorldSize.y \x3e 0.0)\r\n\t\t\t\tscale \x3d min(1.0, minMaxWorldSize.y / combinedSize.y);\r\n\r\n\t\t\tvec2 uv01 \x3d floor($uv0);\r\n\t\t\tvec2 uv \x3d $uv0 - uv01;\r\n\t\t\tposView.xy +\x3d (uv01 - anchorPos) * combinedSize * scale;\r\n\t\t\tuv.y +\x3d (1.0 - texScale.y);\r\n\t\t\tvtc.xy \x3d uv;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tposProj \x3d proj * vec4(posView,1.0);\r\n\t\tposProj.xy +\x3d screenOffset / viewport.zw * posProj.w;\r\n\t\tgl_Position \x3d posProj;\r\n\t\tvcolor \x3d $color;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\r\n\x3csnippet name\x3d"calcLabelDirections"\x3e\x3c![CDATA[\r\n\tvec2 uv01 \x3d floor($uv0);\r\n\tvec2 uv \x3d $uv0 - uv01;\r\n\r\n\tvec3 labelDir, labelDirOrtho;\r\n\r\n\tint isUp \x3d 0;\r\n\tvec2 vId \x3d (uv01 - vec2(.5, .5))*2.0;\r\n\r\n\tvec3 viewDirInNormalPlane \x3d normalize(camDir.xyz - dot(camDir.xyz, direction)*direction);\r\n\tfloat angleToNormal \x3d abs(dot(viewDirInNormalPlane,up));\r\n\tfloat angleToDirection \x3d abs(dot(camDir.xyz, direction));\r\n\tif (angleToDirection \x3c 0.985 \x26\x26 angleToNormal \x3c 0.500)\r\n\t{\r\n\t    if (angleToNormal \x3c 0.422) {\r\n\t\t    isUp \x3d 1;\r\n\t\t    labelDir \x3d direction;\r\n\t\t    labelDirOrtho \x3d up;\r\n\t\t    vId.y +\x3d 0.5;\r\n\t\t} else {\r\n\t\t    labelDir \x3d direction;\r\n            labelDirOrtho \x3d cross(viewDirInNormalPlane, direction);\r\n            vId.y +\x3d dot(labelDirOrtho, up)*0.5;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlabelDir \x3d direction;\r\n\t\tlabelDirOrtho \x3d normalize(cross(up,direction));\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDDirection"\x3e\x3c![CDATA[\r\n \tuniform vec3 direction;\r\n \t\r\n\tvoid main(void) {\r\n\t    vec4 centerOffset \x3d $auxpos1;\r\n\t    vec2 combinedSize \x3d $size * pixelRatio;\r\n\r\n        vec4 posProjCenter;\r\n \t\t$calcPosMatchPixelCenter\r\n\r\n \t\tvec3 direction \x3d normalize(direction);\r\n \t\tvec3 up \x3d vnormal;\r\n \t\tvec3 camDir \x3d normalize(vec3(view[0][2],view[1][2],view[2][2]));\r\n\r\n #ifdef OCCL_TEST\r\n \t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n #endif\r\n\r\n \t\t\t$calcLabelDirections\r\n\r\n\t\t    float scale;\r\n\t\t    if (proj[2][3] !\x3d 0.0)  // perspective projection\r\n \t\t\t    scale \x3d posProj.w*0.5/viewport[2];\r\n \t\t\telse                    // othographic projection\r\n \t\t\t    scale \x3d 2.0/proj[0][0]/viewport[2];\r\n\r\n \t\t\tposModel.xyz +\x3d labelDir * vId.x * combinedSize.x * scale ;\r\n \t\t\tposModel.xyz +\x3d labelDirOrtho * vId.y * combinedSize.y * scale;\r\n\r\n \t\t\tvec4 posDirProj \x3d proj*view*model * vec4($position+direction, 1.0);\r\n \t\t\tvec4 posProjUnmodified \x3d proj*view*model * vec4($position, 1.0);\r\n \t\t\tif (posDirProj.x\x3cposProjUnmodified.x)\r\n \t\t\t{\r\n \t\t\t\tif (isUp\x3d\x3d1)\r\n \t\t\t\t\tuv.x \x3d texScale.x-uv.x;\r\n \t\t\t\telse\r\n \t\t\t\t\tuv \x3d texScale-uv;\r\n \t\t\t}\r\n \t\t\tvtc.xy \x3d uv;\r\n #ifdef OCCL_TEST\r\n \t\t} else {\r\n \t\t\tvtc \x3d vec2(.0);\r\n \t\t}\r\n #endif\r\n\r\n #ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n \t\tvec4 pos4 \x3d proj * view * vec4(posModel,1.0);\r\n \t\tgl_Position \x3d pos4;\r\n \t}\r\n ]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDDirectionWorldScale"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n    \r\n\tuniform vec2 minMaxWorldSizeFactor;\r\n\tuniform vec3 direction;\r\n\r\n\t$matchPixelCenter\r\n\t$matchPixelOrigin\r\n\r\n\tvoid main(void) {\r\n\t    vec4 centerOffset \x3d $auxpos1;\r\n\t    vec2 combinedSize \x3d $size * pixelRatio;\r\n\r\n        vec4 posProjCenter;\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n\t\tvec3 direction \x3d normalize(direction);\r\n\t\tvec3 up \x3d vnormal;\r\n\t\tvec3 camDir \x3d normalize(vec3(view[0][2],view[1][2],view[2][2]));\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\r\n\t\t\t$calcLabelDirections\r\n\r\n\t\t\tfloat scale \x3d 1.0;\r\n\t\t\tvec2 minMaxWorldSize \x3d minMaxWorldSizeFactor;\r\n\t\t\tif (proj[2][3] !\x3d 0.0)  // perspective projection\r\n\t\t\t\tminMaxWorldSize \x3d distance(camPos, position)*minMaxWorldSizeFactor;\r\n\t\t\tif (minMaxWorldSize.x \x3e combinedSize.y)\r\n\t\t\t\tscale \x3d minMaxWorldSize.x / combinedSize.y;\r\n\t\t\telse if (minMaxWorldSize.y \x3e 0.0)\r\n\t\t\t\tscale \x3d min(1.0, minMaxWorldSize.y / combinedSize.y);\r\n\r\n\t\t\tposModel.xyz +\x3d labelDir*vId.x*combinedSize.x*scale;\r\n\t\t\tposModel.xyz +\x3d labelDirOrtho*vId.y*combinedSize.y*scale;\r\n\r\n\t\t\tvec4 posDirProj \x3d proj*view*model * vec4($position+direction, 1.0);\r\n\t\t\tvec4 posProjUnmodified \x3d proj*view*model * vec4($position, 1.0);\r\n \t\t\tif (posDirProj.x\x3cposProjUnmodified.x)\r\n \t\t\t{\r\n \t\t\t\tif (isUp\x3d\x3d1)\r\n \t\t\t\t\tuv.x \x3d texScale.x-uv.x;\r\n \t\t\t\telse\r\n \t\t\t\t\tuv \x3d texScale-uv;\r\n \t\t\t}\r\n \t\t\tuv.y +\x3d (1.0 - texScale.y);\r\n\t\t\tvtc.xy \x3d uv;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tvec4 pos4 \x3d proj * view * vec4(posModel,1.0);\r\n\t\tgl_Position \x3d pos4;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUD"\x3e\x3c![CDATA[\r\n\tprecision mediump float;\r\n\r\n\t#extension GL_OES_standard_derivatives : require\r\n\r\n\tuniform sampler2D tex;\r\n\tuniform vec4 overrideColor;\r\n\tuniform vec4 outlineColor;\r\n\tuniform float outlineSize;\r\n\r\n\tvarying vec4 vcolor;\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvarying vec4 vtc;\r\n\tuniform vec3 markerColor;\r\n\tuniform sampler2D framebufferTex;\r\n#else\r\n\tvarying vec2 vtc;\r\n\tvarying vec2 vsize;\r\n#endif\r\n\r\n\tvoid main() {\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n   \t\tif (texture2D(framebufferTex, vtc.zw).rgb !\x3d markerColor)\r\n   \t\t\tdiscard;\r\n#endif\r\n\r\n#ifdef SIGNED_DISTANCE_FIELD\r\n\t\tvec4 color \x3d vec4(0.0, 0.0, 0.0, 0.0);\r\n\t\tvec4 fillPixelColor \x3d overrideColor * vcolor;\r\n\r\n\t\t// Distance in [-0.5, 0.5]\r\n\t\tfloat d \x3d dot(texture2D(tex, vtc), vec4(1.0/16777216.0, 1.0/65535.0, 1.0/256.0, 1.0)) - 0.5;\r\n\t\t// Distance in output units\r\n\t\tfloat dist \x3d d * vsize.x;\r\n\r\n\t\tfillPixelColor.a *\x3d clamp(0.5 - dist, 0.0, 1.0);\r\n\r\n\t\tif (outlineSize \x3e 0.25) {\r\n\t\t\tvec4 outlinePixelColor \x3d outlineColor;\r\n\t\t\tfloat clampedOutlineSize \x3d min(outlineSize, 0.5*vsize.x);\r\n\t\t\toutlinePixelColor.a *\x3d clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\r\n\r\n\t\t\t// perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\r\n\t\t\tfloat compositeAlpha \x3d outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\t\t\tvec3 compositeColor \x3d vec3(outlinePixelColor) * outlinePixelColor.a +\r\n\t\t\t\tvec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\t\t\tcompositeColor /\x3d compositeAlpha;\r\n\r\n\t\t\tgl_FragColor \x3d vec4(compositeColor, compositeAlpha);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tgl_FragColor \x3d fillPixelColor;\r\n\t\t}\r\n\r\n\t\t// visualize SDF:\r\n\t\t// gl_FragColor \x3d vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\r\n#else\r\n\t\tgl_FragColor \x3d texture2D(tex, vtc, -0.5) * overrideColor * vcolor;\r\n#endif\r\n\r\n\t\tif (gl_FragColor.a \x3c 0.1) {\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\x3csnippet name\x3d"vertexShaderOcclusionTestPixel"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n\tuniform vec4 viewport;\r\n\tuniform vec3 camPos;\r\n\tuniform float polygonOffset;\r\n\r\n\tattribute vec3 $position;\r\n\tattribute vec3 $normal;\r\n\tattribute vec4 $auxpos1;\r\n\r\n\t$matchPixelCenter\r\n\r\n\tvoid main(void) {\r\n\t    vec4 centerOffset \x3d $auxpos1;\r\n\r\n\t    vec4 posProjCenter;\r\n\t    if (dot($position, $position) \x3e 0.0) {\r\n\t\t    $calcPosMatchPixelCenter\r\n\t\t} else {\r\n\t\t    posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\r\n\t\t}\r\n\r\n\t\tgl_Position \x3d posProjCenter;\r\n\t\tgl_PointSize \x3d 1.0;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e'}});
define("dojo/_base/lang dojo/text!./HUDMaterial.xml ./internal/MaterialUtil ../lib/GLSLProgram ../lib/GLSLShader ../lib/ShaderVariations ../lib/VertexBufferLayout ../lib/Util ../lib/gl-matrix ../lib/webglConstants".split(" "),function(E,F,v,G,D,H,I,z,B,y){var J=B.vec2d,w=B.vec3d,K=B.mat4d,A=z.assert,g=z.VertexAttrConstants,C={bottomLeft:[0,0],bottom:[0.5,0],bottomRight:[1,0],left:[0,0.5],center:[0.5,0.5],right:[1,0.5],topLeft:[0,1],top:[0.5,1],topRight:[1,1]};z=function(c,x){v.basicMaterialConstructor(this,
x);c=c||null;c.texCoordScale=c.texCoordScale||[1,1];c.occlusionTest=void 0!==c.occlusionTest?c.occlusionTest:!0;c.color=c.color||[1,1,1,1];c.screenMinMaxSize=c.screenMinMaxSize||[0,1E5];c.outlineColor=c.outlineColor||[1,1,1,1];c.outlineSize=c.outlineSize||0;c.textureIsSignedDistanceField=c.textureIsSignedDistanceField?1:0;c.screenOffset?c.screenOffset.forEach(function(b,h){c.screenOffset[h]=2*b}):c.screenOffset=[0,0];"string"===typeof c.anchorPos?(A(C[c.anchorPos],"HUDMaterial: invalid anchorPos specified"),
c.anchorPos=C[c.anchorPos]):c.anchorPos||(c.anchorPos=C.center);c.shaderPolygonOffset=c.shaderPolygonOffset||1E-5;var t=new I([g.POSITION,g.NORMAL,g.UV0,g.COLOR,g.SIZE,g.AUXPOS1],[3,3,2,4,2,4],[y.FLOAT,y.FLOAT,y.FLOAT,y.UNSIGNED_BYTE,y.FLOAT,y.FLOAT]),e=t.getStride(),s=4*e;this.dispose=function(){};this.getParameterValues=function(){var b={color:c.color,texCoordScale:c.texCoordScale,polygonOffset:c.polygonOffset,anchorPos:c.anchorPos,screenOffset:c.screenOffset,screenMinMaxSize:c.screenMinMaxSize,
shaderPolygonOffset:c.shaderPolygonOffset,textureIsSignedDistanceField:c.textureIsSignedDistanceField,outlineColor:c.outlineColor,outlineSize:c.outlineSize};c.textureId&&(b.textureId=c.textureId);c.direction&&(b.direction=c.direction);return b};this.setParameterValues=function(b){for(var h in b)"textureId"===h&&A(c.textureId,"Can only change texture of material that already has a texture"),"direction"===h&&A(c.direction,"Can only change direction of HUDMaterial which was initialized with a direction"),
c[h]=b[h];this.notifyDirty("matChanged")};this.getParams=function(){return c};this.getOutputAmount=function(b){return 6*b*e};this.getVertexBufferLayout=function(){return t};this.fillInterleaved=function(b,h,d,m,f,l){m=v.fill;for(var q=t.getAttributes(),p=b.faces.indices[g.POSITION],r=b.vertexAttr[g.POSITION].data,a=l+q[g.POSITION].offset,n=0;n<p.length;++n){var k=3*p[n];m(r,k,f,a,h,3);a+=e;m(r,k,f,a,h,3);a+=e;m(r,k,f,a,h,3);a+=e;m(r,k,f,a,h,3);a+=e;m(r,k,f,a,h,3);a+=e;m(r,k,f,a,h,3);a+=e}h=b.faces.indices[g.NORMAL];
r=b.vertexAttr[g.NORMAL].data;a=l+q[g.NORMAL].offset;for(n=0;n<h.length;++n)k=3*h[n],m(r,k,f,a,d,3),a+=e,m(r,k,f,a,d,3),a+=e,m(r,k,f,a,d,3),a+=e,m(r,k,f,a,d,3),a+=e,m(r,k,f,a,d,3),a+=e,m(r,k,f,a,d,3),a+=e;a=l+q[g.UV0].offset;n=b.vertexAttr[g.UV0].data;null==n||3>=n.length?(d=k=0,h=c.texCoordScale[0],r=c.texCoordScale[1]):(k=b.vertexAttr[g.UV0].data[0],d=b.vertexAttr[g.UV0].data[1],h=b.vertexAttr[g.UV0].data[2],r=b.vertexAttr[g.UV0].data[3]);h=Math.min(1.99999,h+1);r=Math.min(1.99999,r+1);for(n=0;n<
p.length;++n)f[a]=k,f[a+1]=d,a+=e,f[a]=h,f[a+1]=d,a+=e,f[a]=h,f[a+1]=r,a+=e,f[a]=h,f[a+1]=r,a+=e,f[a]=k,f[a+1]=r,a+=e,f[a]=k,f[a+1]=d,a+=e;p=b.faces.indices[g.COLOR];d=b.vertexAttr[g.COLOR].data;a=4*(l+q[g.COLOR].offset);h=new Uint8Array(f.buffer);for(n=0;n<p.length;++n)k=4*p[n],m(d,k,h,a,null,4),a+=s,m(d,k,h,a,null,4),a+=s,m(d,k,h,a,null,4),a+=s,m(d,k,h,a,null,4),a+=s,m(d,k,h,a,null,4),a+=s,m(d,k,h,a,null,4),a+=s;p=b.faces.indices[g.SIZE];k=b.vertexAttr[g.SIZE].data;a=l+q[g.SIZE].offset;for(n=0;n<
p.length;++n)d=k[2*p[n]],h=k[2*p[n]+1],f[a]=d,f[a+1]=h,a+=e,f[a]=d,f[a+1]=h,a+=e,f[a]=d,f[a+1]=h,a+=e,f[a]=d,f[a+1]=h,a+=e,f[a]=d,f[a+1]=h,a+=e,f[a]=d,f[a+1]=h,a+=e;if(null!=b.faces.indices[g.AUXPOS1]&&null!=b.vertexAttr[g.AUXPOS1]){p=b.faces.indices[g.AUXPOS1];b=b.vertexAttr[g.AUXPOS1].data;a=l+q.auxpos1.offset;for(n=0;n<b.length;++n)k=4*p[n],m(b,k,f,a,null,4),a+=e,m(b,k,f,a,null,4),a+=e,m(b,k,f,a,null,4),a+=e,m(b,k,f,a,null,4),a+=e,m(b,k,f,a,null,4),a+=e,m(b,k,f,a,null,4),a+=e}};var d=w.create(),
q=w.create(),l=[0,0],u=c.anchorPos;this.intersect=function(b,c,e,m,f,s,x,p,r,a,n,k){if(k){c=b.getData().getVertexAttr()[g.POSITION];b=b.getData().getVertexAttr()[g.SIZE];A(3<=c.size);for(x=0;x<c.data.length/c.size;x++)if(p=x*c.size,w.set3(c.data[p],c.data[p+1],c.data[p+2],d),K.multiplyVec3(e,d,d),p=x*b.size,l[0]=b.data[p],l[1]=b.data[p+1],r.projectPoint(d,q),-1<q[0]){p=q[0]-1-(0<u[0]?l[0]*u[0]:0);a=p+l[0];k=q[1]-1-(0<u[1]?l[1]*u[1]:0);var t=k+l[1];m[0]>p&&(m[0]<a&&m[1]>k&&m[1]<t)&&(p=w.subtract(f,
d,w.create()),a=w.length(p),w.scale(p,1/a),a=0.98*a/w.dist(f,s),n(a,p,-1,1,!0))}}};this.getGLMaterials=function(){return[L,void 0,void 0]};this.getAllTextureIds=function(){return[c.textureId]};this._textureDirty=!1;this.setTextureDirty=function(){this._textureDirty=!0}};var L=function(c,g,t){function e(){return g.shaderVariators.HUDMaterial.getProgram([!!d.direction,!!d.worldScale,d.occlusionTest,d.textureIsSignedDistanceField])}v.basicGLMaterialConstructor(this,c);var s=0,d=E.clone(c.getParams()),
q=g.get("hudOcclusionTestPixel"),l=e();v.singleTextureGLMaterialConstructor(this,t,d);var u=[254/255,253/255,252/255];this.beginSlot=function(b){s=b;return d.occlusionTest?2===b||4==b:2===b};this.getProgram=function(){return 2===s&&d.occlusionTest?q:l};this.getAllPrograms=function(){return[q,l]};this.updateParameters=function(){var b=c.getParams();d.color=b.color;d.texCoordScale=b.texCoordScale;d.polygonOffset=b.polygonOffset;d.anchorPos=b.anchorPos;d.screenOffset=b.screenOffset;d.screenMinMaxSize=
b.screenMinMaxSize;d.direction=b.direction;d.shaderPolygonOffset=b.shaderPolygonOffset;d.textureIsSignedDistanceField=b.textureIsSignedDistanceField;d.outlineColor=b.outlineColor;d.outlineSize=b.outlineSize;this.updateTexture(b.textureId);l=e()};this.bind=function(b,h){c._textureDirty&&(this.renderTexture(b),c._textureDirty=!1);if(2===s&&d.occlusionTest)q.use(),q.uniform1f("polygonOffset",d.shaderPolygonOffset),q.uniform4fv("viewport",h.viewport),q.uniform4f("color",u[0],u[1],u[2],1),c.getVertexBufferLayout().enableVertexAttribArrays(b,
q),b.depthFunc(b.LEQUAL);else{l.use();this.bindTexture(b,l);l.uniform1i("framebufferTex",1);b.activeTexture(b.TEXTURE1);b.bindTexture(b.TEXTURE_2D,h.framebufferTex);b.activeTexture(b.TEXTURE0);l.uniform3fv("markerColor",u);l.uniform4fv("viewport",h.viewport);l.uniform4fv("overrideColor",d.color);l.uniform1f("pixelRatio",h.pixelRatio);l.uniform1f("polygonOffset",d.shaderPolygonOffset);d.textureIsSignedDistanceField&&(l.uniform4fv("outlineColor",d.outlineColor),l.uniform1f("outlineSize",d.outlineSize));
if(d.worldScale){var e=[-1,-1],m=d.screenMinMaxSize,f=h.proj,g=h.viewport[2]/h.pixelRatio;m&&(0!==f[11]?(f=2*Math.atan(1/f[0]),g=2*(Math.tan(f/2)/g),e[0]=m[0]*g,e[1]=m[1]*g):J.scale(m,2/(f[0]*g),e));l.uniform2fv("minMaxWorldSizeFactor",e)}d.direction&&l.uniform3fv("direction",d.direction);l.uniform2fv("texScale",d.texCoordScale);l.uniform2fv("screenOffset",d.screenOffset);l.uniform2fv("anchorPos",d.anchorPos);c.getVertexBufferLayout().enableVertexAttribArrays(b,l);d.polygonOffset&&(b.enable(b.POLYGON_OFFSET_FILL),
b.polygonOffset(0,-4));b.web3DDefaultState.cullEnabled&&b.disable(b.CULL_FACE);b.enable(b.BLEND)}};this.release=function(b){2===s&&d.occlusionTest?(b.depthFunc(b.LESS),c.getVertexBufferLayout().disableVertexAttribArrays(b,q)):(d.polygonOffset&&b.disable(b.POLYGON_OFFSET_FILL),b.web3DDefaultState.cullEnabled&&b.enable(b.CULL_FACE),b.disable(b.BLEND),c.getVertexBufferLayout().disableVertexAttribArrays(b,l))};this.bindView=function(b,c){var e=c.origin;2===s&&d.occlusionTest?(v.bindView(e,c.view,q),v.bindCamPos(e,
c.viewInvTransp,q)):(v.bindView(e,c.view,l),v.bindCamPos(e,c.viewInvTransp,l))};this.bindInstance=function(b,c){2===s&&d.occlusionTest?(q.uniformMatrix4fv("model",c.transformation),q.uniformMatrix4fv("modelNormal",c.transformationNormal)):l.uniformMatrix4fv("model",c.transformation)};this.getDrawMode=function(b){return 2===s&&d.occlusionTest?b.POINTS:b.TRIANGLES}};z.loadShaders=function(c,g,t,e){c._parse(F);var s=0<e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);g=new H("hud",["vertexShaderHUD",
"fragmentShaderHUD"],null,t,g,c,e);g.addBinaryShaderSnippetSuffix("Direction","Direction",[!0,!1]);g.addBinaryShaderSnippetSuffix("WorldScale","WorldScale",[!0,!1]);g.addDefine("OcclTest",s?"OCCL_TEST":"OCCL_PIXELSHADER");g.addDefine("SDF","SIGNED_DISTANCE_FIELD");t.shaderVariators.HUDMaterial=g;s=new D(e.VERTEX_SHADER,c.vertexShaderOcclusionTestPixel,e);c=new D(e.FRAGMENT_SHADER,c.fragmentShaderSimple,e);e=new G([s,c],e);t.add("hudOcclusionTestPixel",e)};return z});